<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <link rel="stylesheet" type="text/css" href="css/bootstrap.min.css">
    <link rel="stylesheet" type="text/css" href="css/common.css">
    <title></title>
</head>
<body>
<script type="text/javascript" color="255,0,0" opacity="0.5" count="99" src="js/canvas-nest.min.js"></script>
<div id="watch-example">
	
</div>
<div id="vmApp" style="width: 1080px;margin: 0 auto;">
    <div >{{a}}</div>
    <div class="static" v-bind:class = "{active:isActive,'text-danger':hasError }">v-bind class   </div>
</div>


<div id="app" style="padding: 20px;width: 1080px;margin: 0 auto;" >
    <fucom></fucom>
    <ol class="">
        <todo-item v-for="item in groceryList" v-bind:todo="item"  v-bind:key="item.id">

        </todo-item>
    </ol>
    <ol class="">
        <tdo-item v-for="item in nav" :tdo="item">

        </tdo-item>
    </ol>
    <div class="clear">
        <ul>
            <li class="left" v-for="i in nav">
                {{ i.text }}
            </li>
        </ul>
    </div>
    <div v-bind:style="styleObject">{{ message.a }}</div>
    <div >
        <span v-bind:title="loadTime">v-bind指令绑定title 鼠标指向显示加载时间</span>
    </div>
    <div>
        <p v-if="seen">条件语句 显示隐藏</p>
    </div>
    <div>
        <p> {{message1}} </p>
        <button v-on:click="reverseMes">反转消息</button>
    </div>
    <div>
        <p>{{ modelData }}</p>
        <input class="" type="text" placeholder="" v-model="modelData" >
    </div>
	<div>
		<a @:click.stop="doThis">.stop阻止事件继续传播</a>
		<form @:click.submit.prevent="onSubmit">.prevent 提交事件不再重载页面</form>
		<a @:click.stop.prevent="doThat">.stop.prevent修饰符可以串联</a>
		<form @:click.submit.prevent>只有修饰符</form>
		<div @:click.capture="doThis">...添加事件监听器时使用事件捕获模式,即元素自身触发的事件先在此处处理,然后才交由内部元素进行处理</div>
		<div @:click.self="doThat">click.self 只当在event.target是当前元素自身触发处理函数 即事件不是由内部元素触发的</div>
		<div>@:click.prevent.self会阻止所有点击 @:click.self.prevent只会阻止对元素自身的点击          @:click.once 点击事件只会触发一次</div>
		<input @:keyup.enter='submit' placeholder="或者@:keyup.13='submit' 按键盘时触发,其它键类似, 还可以通过全局 config.keyCodes 对象自定义按键修饰符别名">
	</div>
	<div>
		<p>button 组件 可复用的Vue实例,每个组件都会各自独立维护他的数据,因为每用一次组件,就会有一个它的新<b>实例</b>被创建---
		<strong>data 必须是一个函数,因此每个实例可以维护一份被返回对象的独立的拷贝</strong>
		</p>
		<button-counter></button-counter>
		<button-counter></button-counter>
		<button-counter></button-counter>
		<p>为了能在模板中使用,组件必须先注册以便Vue能识别  有两种注册类型:全局注册和局部注册. Vue.component 全局注册 <code>Vue.component('my-component-name',{....})</code>全局注册的组件可以用在被注册之后(通过new Vue)新创建的Vue根实例,也包括其组件树中的所有子组件的模板中</p>
		<p>如果用webpack这样的构建系统,全局注册意味着即便你已经不在使用一个组件了,它仍会被包含在最终的构建结果中,这就造成了用户下载JavaScript的无谓增加</p>
		</p><strong>这些情况下可以通过一个普通的JavaScript对象来定义组件,如下,对于components对象中的每个属性来说,属性名就是自定义元素的名字,属性值就是这个组件的选项对象</strong></p>
		<code>
			var ComponentA={/*.....*/}
			var ComponentB={/*.....*/}
			var ComponentC={/*.....*/}
			// 然后再components选项中定义你想要使用的组件：
			new Vue({
				el:"#app"
				components:{
					'component-a':ComponentA,
					'component-b':ComponentB
				}
			})
		</code>
		<h3>注意 局部注册的组件在其子组件中 不可用 如果希望ComponentA在ComponentB中可用,如下</h3>
		<code>
			var ComponentA = {/*...*/}
			var ComponentB ={
			
				components:{
					'component-a':ComponentA
				},
				//.....
			}
		</code>
		<p><b>通过Prop向子组件传递数据</b> prop是可以在组件上注册一些自定义特性. 当一个值传递给一个prop特性时,它就变成了那个组件实例的一个<b>属性</b>,一个组件可以拥有任意数量的prop</p>
		<p style="color:#4994fc;">所有的prop都使得其父子prop之间形成了一个<b>单向下行绑定</b>:父级prop的更新会向下流动到子组件中,但是反过来则不行.每次父级组件发生更新时,子组件中所有的prop都会刷新为最新的值,这意味着你<b>不</b>应该在子组件内部改变prop,如果你这样做了,Vue会在浏览器的控制台中发出警告.</p>
		
	</div>
</div>

<style lang="scss" scope>
    /*@import 'css/common';*/
    ul li{
        list-style: none;
    }
</style>
<script src="lib/vue.js"></script>
<script src="js/index.js"></script>
<script type="text/javascript">
    // Vue.component('todo-list',{
    //     template : "<li> tedt </li>"
    // })
    // new Vue({
    //     el:"#app2",
    // })
	
</script>

</body>
</html>